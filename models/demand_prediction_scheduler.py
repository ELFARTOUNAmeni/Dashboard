# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
from datetime import datetime, timedelta
import time

_logger = logging.getLogger(__name__)


class DemandPredictionScheduler(models.Model):
    _name = 'demand.prediction.scheduler'
    _description = 'Demand Prediction Scheduler'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    @api.model
    def _run_daily_predictions(self):
        """
        Cron job method to generate daily demand predictions
        """
        _logger.info("Starting scheduled daily demand prediction generation")
        start_time = time.time()

        try:
            # Create a batch for daily predictions
            batch = self.env['demand.prediction.batch'].create({
                'name': f"Daily Forecast {fields.Date.today()}",
                'description': f"Automatically generated by daily cron job on {fields.Datetime.now()}",
                'date': fields.Date.today(),
                'user_id': self.env.user.id,
                'prediction_period': 'daily',
                'model_id': self._get_default_model().id,
                'warehouse_id': self._get_default_warehouse().id,
                'start_date': fields.Date.today(),
                'end_date': fields.Date.today() + timedelta(days=30),  # 30 days forecast
                'include_stockouts': True,
                'seasonality_factor': True,
                'safety_stock_days': 7,
                'state': 'draft',
            })

            # Generate predictions for this batch
            success = batch.create_batch_predictions(batch.id)

            if success:
                # Confirm the batch to create alerts
                batch.action_confirm()

                # Log success
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'daily_cron',
                    'success',
                    f"Successfully generated daily demand predictions, batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.info(f"Daily demand prediction completed successfully in {execution_time:.2f} seconds")
            else:
                # Log failure
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'daily_cron',
                    'failed',
                    f"Failed to generate predictions for batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.error(f"Failed to generate daily demand predictions for batch ID: {batch.id}")

            return True

        except Exception as e:
            # Log error
            execution_time = time.time() - start_time
            error_message = f"Error in daily demand prediction cron job: {str(e)}"
            _logger.error(error_message)

            self.env['demand.prediction.log'].log_operation(
                'daily_cron',
                'failed',
                error_message,
                execution_time
            )

            # Don't raise the exception to prevent the cron job from failing
            return False

    @api.model
    def _run_weekly_predictions(self):
        """
        Cron job method to generate weekly demand predictions
        """
        _logger.info("Starting scheduled weekly demand prediction generation")
        start_time = time.time()

        try:
            # Create a batch for weekly predictions
            batch = self.env['demand.prediction.batch'].create({
                'name': f"Weekly Forecast {fields.Date.today()}",
                'description': f"Automatically generated by weekly cron job on {fields.Datetime.now()}",
                'date': fields.Date.today(),
                'user_id': self.env.user.id,
                'prediction_period': 'weekly',
                'model_id': self._get_default_model().id,
                'warehouse_id': self._get_default_warehouse().id,
                'start_date': fields.Date.today(),
                'end_date': fields.Date.today() + timedelta(weeks=12),  # 12 weeks forecast
                'include_stockouts': True,
                'seasonality_factor': True,
                'safety_stock_days': 14,
                'state': 'draft',
            })

            # Generate predictions for this batch
            success = batch.create_batch_predictions(batch.id)

            if success:
                # Confirm the batch to create alerts
                batch.action_confirm()

                # Log success
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'weekly_cron',
                    'success',
                    f"Successfully generated weekly demand predictions, batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.info(f"Weekly demand prediction completed successfully in {execution_time:.2f} seconds")
            else:
                # Log failure
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'weekly_cron',
                    'failed',
                    f"Failed to generate predictions for batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.error(f"Failed to generate weekly demand predictions for batch ID: {batch.id}")

            return True

        except Exception as e:
            # Log error
            execution_time = time.time() - start_time
            error_message = f"Error in weekly demand prediction cron job: {str(e)}"
            _logger.error(error_message)

            self.env['demand.prediction.log'].log_operation(
                'weekly_cron',
                'failed',
                error_message,
                execution_time
            )

            # Don't raise the exception to prevent the cron job from failing
            return False

    @api.model
    def _run_monthly_predictions(self):
        """
        Cron job method to generate monthly demand predictions
        """
        _logger.info("Starting scheduled monthly demand prediction generation")
        start_time = time.time()

        try:
            # Create a batch for monthly predictions
            batch = self.env['demand.prediction.batch'].create({
                'name': f"Monthly Forecast {fields.Date.today().strftime('%Y-%m')}",
                'description': f"Automatically generated by monthly cron job on {fields.Datetime.now()}",
                'date': fields.Date.today(),
                'user_id': self.env.user.id,
                'prediction_period': 'monthly',
                'model_id': self._get_default_model().id,
                'warehouse_id': self._get_default_warehouse().id,
                'start_date': fields.Date.today(),
                'end_date': fields.Date.today() + timedelta(days=365),  # 1 year forecast
                'include_stockouts': True,
                'seasonality_factor': True,
                'safety_stock_days': 30,
                'state': 'draft',
            })

            # Generate predictions for this batch
            success = batch.create_batch_predictions(batch.id)

            if success:
                # Confirm the batch to create alerts
                batch.action_confirm()

                # Log success
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'monthly_cron',
                    'success',
                    f"Successfully generated monthly demand predictions, batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.info(f"Monthly demand prediction completed successfully in {execution_time:.2f} seconds")
            else:
                # Log failure
                execution_time = time.time() - start_time
                self.env['demand.prediction.log'].log_operation(
                    'monthly_cron',
                    'failed',
                    f"Failed to generate predictions for batch ID: {batch.id}",
                    execution_time,
                    batch.id
                )

                _logger.error(f"Failed to generate monthly demand predictions for batch ID: {batch.id}")

            return True

        except Exception as e:
            # Log error
            execution_time = time.time() - start_time
            error_message = f"Error in monthly demand prediction cron job: {str(e)}"
            _logger.error(error_message)

            self.env['demand.prediction.log'].log_operation(
                'monthly_cron',
                'failed',
                error_message,
                execution_time
            )

            # Don't raise the exception to prevent the cron job from failing
            return False

    @api.model
    def _run_wizard_predictions(self, **kwargs):
        """
        Cron job method to generate predictions using the wizard
        This allows more customization through parameters
        """
        _logger.info("Starting scheduled wizard-based demand prediction generation")
        start_time = time.time()

        try:
            # Create wizard with parameters from kwargs or defaults
            wizard_vals = {
                'forecast_name': kwargs.get('forecast_name', f"Scheduled Forecast {fields.Date.today()}"),
                'forecast_description': kwargs.get('forecast_description',
                                                   f"Automatically generated by cron job on {fields.Datetime.now()}"),
                'forecast_start_date': kwargs.get('forecast_start_date', fields.Date.today()),
                'forecast_days': kwargs.get('forecast_days', 30),
                'product_selection': kwargs.get('product_selection', 'all'),
                'model_id': kwargs.get('model_id', self._get_default_model().id),
                'warehouse_id': kwargs.get('warehouse_id', self._get_default_warehouse().id),
                'prediction_period': kwargs.get('prediction_period', 'daily'),
                'include_stockouts': kwargs.get('include_stockouts', True),
                'seasonality_factor': kwargs.get('seasonality_factor', True),
                'safety_stock_days': kwargs.get('safety_stock_days', 7),
                'debug_mode': kwargs.get('debug_mode', True),
            }

            # Add product_ids if specified
            if kwargs.get('product_ids'):
                wizard_vals['product_ids'] = [(6, 0, kwargs.get('product_ids'))]

            # Add product_category_id if specified
            if kwargs.get('product_category_id'):
                wizard_vals['product_category_id'] = kwargs.get('product_category_id')

            # Create and execute wizard
            wizard = self.env['generate.demand.prediction.wizard'].create(wizard_vals)
            result = wizard.action_generate_demand_predictions()

            # Log success
            execution_time = time.time() - start_time
            self.env['demand.prediction.log'].log_operation(
                'wizard_cron',
                'success',
                f"Successfully generated demand predictions using wizard",
                execution_time
            )

            _logger.info(f"Wizard-based demand prediction completed successfully in {execution_time:.2f} seconds")
            return result

        except Exception as e:
            # Log error
            execution_time = time.time() - start_time
            error_message = f"Error in wizard-based demand prediction cron job: {str(e)}"
            _logger.error(error_message)

            self.env['demand.prediction.log'].log_operation(
                'wizard_cron',
                'failed',
                error_message,
                execution_time
            )

            # Don't raise the exception to prevent the cron job from failing
            return False

    @api.model
    def _get_default_model(self):
        """Get the default prediction model to use"""
        model = self.env['demand.prediction.model'].search([('active', '=', True)], limit=1)
        if not model:
            _logger.warning("No active prediction model found. Please create one.")
            return self.env['demand.prediction.model']
        return model

    @api.model
    def _get_default_warehouse(self):
        """Get the default warehouse to use"""
        warehouse = self.env['stock.warehouse'].search([], limit=1)
        if not warehouse:
            _logger.warning("No warehouse found. Please create one.")
            return self.env['stock.warehouse']
        return warehouse
