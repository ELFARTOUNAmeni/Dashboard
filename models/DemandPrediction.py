# -*- coding: utf-8 -*-
from odoo import models, fields, api, Command, _
from odoo.exceptions import UserError, ValidationError
import logging
import base64
from datetime import datetime, timedelta
import time
from dateutil.relativedelta import relativedelta

_logger = logging.getLogger(__name__)


class DemandPrediction(models.Model):
    _name = 'demand.prediction'
    _description = 'Demand Prediction'
    _order = 'date desc, id desc'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char('Name', required=True, tracking=True)
    date = fields.Date('Date', required=True, index=True, tracking=True)
    product_id = fields.Many2one('product.product', string='Product', required=True, index=True, tracking=True)
    warehouse_id = fields.Many2one('stock.warehouse', string='Warehouse', required=True, index=True, tracking=True)
    prediction_value = fields.Float('Predicted Demand', required=True, tracking=True)
    prediction_period = fields.Selection([
        ('daily', 'Daily'),
        ('weekly', 'Weekly'),
        ('monthly', 'Monthly'),
        ('quarterly', 'Quarterly'),
        ('yearly', 'Yearly')
    ], string='Prediction Period', default='daily', required=True, tracking=True)
    model_id = fields.Many2one('demand.prediction.model', string='Model', required=True, tracking=True)
    generator_id = fields.Many2one('res.users', string='Generated By', required=True, tracking=True)
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', required=True, tracking=True)
    start_date = fields.Date('Period Start Date', required=True, tracking=True)
    end_date = fields.Date('Period End Date', required=True, tracking=True)
    description = fields.Text('Description', tracking=True)
    batch_id = fields.Many2one('demand.prediction.batch', string='Batch', index=True, tracking=True)
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company, tracking=True)
    includes_safety_stock = fields.Boolean('Includes Safety Stock', default=False, tracking=True)
    safety_stock_days = fields.Integer('Safety Stock Days', default=0, tracking=True)

    # Additional fields for demand prediction
    actual_demand = fields.Float('Actual Demand', compute='_compute_actual_demand', store=True,
                                 help="Actual demand recorded for this period (filled after the period)", tracking=True)

    stockout_adjusted = fields.Boolean('Stockout Adjusted', default=False,
                                       help="Indicates if this prediction was adjusted for stockouts", tracking=True)
    seasonality_factor = fields.Float('Seasonality Factor', default=1.0,
                                      help="Seasonality factor applied to this prediction", tracking=True)


    # New fields for alert management
    alert_created = fields.Boolean('Alert Created', default=False, tracking=True)
    current_stock = fields.Float('Current Stock', compute='_compute_current_stock', store=True)

    @api.depends('product_id', 'warehouse_id')
    def _compute_current_stock(self):
        """Compute the current stock level for the product in the warehouse"""
        for record in self:
            if not (record.product_id and record.warehouse_id):
                record.current_stock = 0.0
                continue

            # Get stock locations for this warehouse
            warehouse_locations = self.env['stock.location'].search([
                ('warehouse_id', '=', record.warehouse_id.id),
                ('usage', '=', 'internal')
            ])

            if not warehouse_locations:
                record.current_stock = 0.0
                continue

            # Get current quants for this product in these locations
            quants = self.env['stock.quant'].search([
                ('product_id', '=', record.product_id.id),
                ('location_id', 'in', warehouse_locations.ids)
            ])

            # Sum up the quantities
            record.current_stock = sum(quant.quantity for quant in quants)

    # Version améliorée (prend en compte les commandes clients même non livrées)
    @api.depends('product_id', 'warehouse_id')
    def _compute_actual_demand(self):
        for record in self:
            if not (record.product_id and record.warehouse_id):
                record.actual_demand = 0.0
                continue

            # 1. Commandes clients confirmées (en état 'sale' ou 'done')
            confirmed_orders = self.env['sale.order.line'].search([
                ('product_id', '=', record.product_id.id),
                ('order_id.state', 'in', ['sale', 'done']),
                ('order_id.warehouse_id', '=', record.warehouse_id.id),
            ])

            # 2. Mouvements de stock sortants (livraisons) depuis l'entrepôt
            warehouse_locations = record.warehouse_id.lot_stock_id
            outgoing_moves = self.env['stock.move'].search([
                ('product_id', '=', record.product_id.id),
                ('state', '=', 'done'),
                ('location_id', '=', warehouse_locations.id),
                ('picking_code', '=', 'outgoing'),
            ])

            # Prendre la quantité la plus élevée entre commandes confirmées et livraisons réelles
            confirmed_qty = sum(order.product_uom_qty for order in confirmed_orders)
            delivered_qty = sum(move.quantity_done for move in outgoing_moves)

            record.actual_demand = max(confirmed_qty, delivered_qty)
    def action_confirm(self):
        """Override to automatically create alerts when predictions are confirmed"""
        for record in self:
            record.state = 'confirmed'
            # Create alerts for confirmed predictions
            if not record.alert_created:
                record._create_alerts()

    def action_cancel(self):
        for record in self:
            record.state = 'cancelled'

    def action_reset_to_draft(self):
        for record in self:
            record.state = 'draft'

    def _create_alerts(self):
        """Create alerts based on prediction data"""
        self.ensure_one()
        AlertModel = self.env['demand.prediction.alert']

        # Skip if alert already created
        if self.alert_created:
            return

        # Get current stock from computed field
        current_stock = self.current_stock

        # Determine alert type and severity based on stock level and prediction
        if current_stock <= 0:
            alert_type = 'stockout_risk'
            severity = '4'  # Critical
        elif current_stock < self.prediction_value * 0.5:
            alert_type = 'low_stock'
            severity = '3'  # High
        elif current_stock < self.prediction_value:
            alert_type = 'low_stock'
            severity = '2'  # Medium
        elif current_stock > self.prediction_value * 2:
            # Optional: create an alert for excess inventory
            alert_type = 'high_stock'
            severity = '1'  # Low
            # Uncomment below if you want to skip high stock alerts
            # return
        else:
            # Stock level is adequate, no alert needed
            return

        # Create the alert
        AlertModel.create_alert(
            prediction=self,
            alert_type=alert_type,
            stock=current_stock,
            severity=severity
        )

        # Mark alert as created
        self.alert_created = True

    def action_send_email_manually(self):
        """Action pour envoyer manuellement un email de notification"""
        self.ensure_one()
        template = self.env.ref('sales_prediction.email_template_alert_notification', raise_if_not_found=True)
        if template:
            # Get the email of the user who should receive the notification
            recipient_email = self.user_id.email
            if not recipient_email:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': _('Error'),
                        'message': _('User %s has no email address configured') % self.user_id.name,
                        'sticky': False,
                        'type': 'danger',
                    }
                }

            # Send email with explicit recipient
            template.with_context(lang=self.user_id.lang).send_mail(
                self.id,
                force_send=True,
                email_values={'email_to': recipient_email}
            )

            self.env['demand.prediction.alert.action'].create({
                'alert_id': self.id,
                'action_type': 'notification',
                'description': _('Email notification sent manually to %s') % recipient_email,
                'user_id': self.env.user.id,
            })

            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _('Email Sent'),
                    'message': _('Email notification sent successfully to %s') % recipient_email,
                    'sticky': False,
                    'type': 'success',
                }
            }


class DemandPredictionBatch(models.Model):
    _name = 'demand.prediction.batch'
    _description = 'Demand Prediction Batch'
    _order = 'date desc, id desc'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char('Name', required=True, tracking=True)
    description = fields.Text('Description', tracking=True)
    date = fields.Date('Generation Date', required=True, default=fields.Date.today, tracking=True)
    user_id = fields.Many2one('res.users', string='Generated By', required=True, default=lambda self: self.env.user,
                              tracking=True)
    prediction_period = fields.Selection([
        ('daily', 'Daily'),
        ('weekly', 'Weekly'),
        ('monthly', 'Monthly'),
        ('quarterly', 'Quarterly'),
        ('yearly', 'Yearly')
    ], string='Prediction Period', default='daily', required=True, tracking=True)
    model_id = fields.Many2one('demand.prediction.model', string='Model', required=True, tracking=True)
    warehouse_id = fields.Many2one('stock.warehouse', string='Warehouse', required=True, tracking=True)
    start_date = fields.Date('Start Date', required=True, tracking=True)
    end_date = fields.Date('End Date', required=True, tracking=True)
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', required=True, tracking=True)
    prediction_count = fields.Integer('Prediction Count', compute='_compute_prediction_count')
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company, tracking=True)
    prediction_ids = fields.One2many('demand.prediction', 'batch_id', string='Predictions')
    include_stockouts = fields.Boolean('Include Stockout Analysis', default=True, tracking=True)
    seasonality_factor = fields.Boolean('Apply Seasonality', default=True, tracking=True)
    safety_stock_days = fields.Integer('Safety Stock Days', default=7, tracking=True)

    # Additional fields for demand prediction



    @api.depends('prediction_ids')
    def _compute_prediction_count(self):
        for record in self:
            record.prediction_count = len(record.prediction_ids)

    def action_confirm(self):
        """Override to ensure alerts are created when batch is confirmed"""
        for record in self:
            record.state = 'confirmed'
            # Confirm all predictions in the batch
            record.prediction_ids.action_confirm()

    def action_cancel(self):
        for record in self:
            record.state = 'cancelled'
            record.prediction_ids.action_cancel()

    def action_reset_to_draft(self):
        for record in self:
            record.state = 'draft'
            record.prediction_ids.action_reset_to_draft()

    @api.model
    def create_batch_predictions(self, batch_id):
        """
        Create predictions for all products in the warehouse for the given batch
        """
        batch = self.browse(batch_id)
        if not batch:
            return False

        # Get all products that have stock moves in the warehouse
        products = self.env['product.product'].search([
            ('type', '=', 'product'),
            ('active', '=', True)
        ])

        prediction_model = batch.model_id

        # Log the start of the operation
        start_time = time.time()
        log_vals = {
            'name': 'Generate Batch Predictions',
            'batch_id': batch.id,
            'model_id': prediction_model.id,
        }

        try:
            # Create predictions for each product
            for product in products:
                # Check if we already have a prediction for this product in this batch
                existing = self.env['demand.prediction'].search([
                    ('batch_id', '=', batch.id),
                    ('product_id', '=', product.id)
                ], limit=1)

                if existing:
                    continue

                # Generate prediction value (this would normally call your ML model)
                prediction_value = self._generate_prediction_value(
                    product,
                    batch.warehouse_id,
                    batch.start_date,
                    batch.end_date,
                    batch.prediction_period,
                    prediction_model
                )

                # Apply factors
                if batch.include_stockouts:
                    prediction_value = self._apply_stockout_factor(
                        prediction_value, product, batch.warehouse_id, batch.start_date, batch.end_date
                    )

                if batch.seasonality_factor:
                    prediction_value = self._apply_seasonality_factor(
                        prediction_value, product, batch.start_date, batch.end_date
                    )

                # Create the prediction
                prediction = self.env['demand.prediction'].create({
                    'name': f"{product.name} - {batch.prediction_period} Prediction",
                    'date': batch.date,
                    'product_id': product.id,
                    'warehouse_id': batch.warehouse_id.id,
                    'prediction_value': prediction_value,
                    'prediction_period': batch.prediction_period,
                    'model_id': prediction_model.id,
                    'generator_id': self.env.user.id,
                    'start_date': batch.start_date,
                    'end_date': batch.end_date,
                    'batch_id': batch.id,
                    'includes_safety_stock': batch.safety_stock_days > 0,
                    'safety_stock_days': batch.safety_stock_days if batch.safety_stock_days > 0 else 0,
                    'stockout_adjusted': batch.include_stockouts,
                    'seasonality_factor': 1.0 if batch.seasonality_factor else 0.0,
                })

                # Compute current stock for the new prediction
                prediction._compute_current_stock()

            # Log success
            execution_time = time.time() - start_time
            log_vals.update({
                'status': 'success',
                'message': f"Successfully generated {len(products)} predictions",
                'execution_time': execution_time
            })
            self.env['demand.prediction.log'].create(log_vals)

            return True

        except Exception as e:
            # Log failure
            execution_time = time.time() - start_time
            log_vals.update({
                'status': 'failed',
                'message': f"Error generating predictions: {str(e)}",
                'execution_time': execution_time
            })
            self.env['demand.prediction.log'].create(log_vals)

            return False

    def _generate_prediction_value(self, product, warehouse, start_date, end_date, period, model):
        """
        Generate a prediction value for the given product and parameters
        This is a placeholder method that would normally call your ML model
        """
        # In a real implementation, this would call your ML model
        # For now, we'll just return a random value based on the product's list price
        # as a placeholder
        return product.list_price * 10

    def _apply_stockout_factor(self, value, product, warehouse, start_date, end_date):
        """
        Apply a stockout factor to the prediction value
        """
        # Check for stockouts in the past
        stockouts = self.env['stock.quant'].search_count([
            ('product_id', '=', product.id),
            ('location_id.warehouse_id', '=', warehouse.id),
            ('quantity', '<=', 0),
            ('create_date', '>=', start_date),
            ('create_date', '<=', end_date)
        ])

        # If there were stockouts, increase the prediction
        if stockouts > 0:
            return value * 1.2  # 20% increase for stockouts
        return value

    def _apply_seasonality_factor(self, value, product, start_date, end_date):
        """
        Apply a seasonality factor to the prediction value
        """
        # This is a placeholder implementation
        # In a real implementation, you would use historical data to determine seasonality

        # For now, we'll just check if it's a holiday season (Q4)
        month = start_date.month
        if 10 <= month <= 12:  # Q4
            return value * 1.3  # 30% increase for holiday season
        return value


class DemandPredictionModel(models.Model):
    _name = 'demand.prediction.model'
    _description = 'Demand Prediction Model'
    _order = 'name'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    name = fields.Char('Name', required=True, tracking=True)
    description = fields.Text('Description', tracking=True)
    model_type = fields.Selection([
        ('prophet', 'Prophet'),
        ('xgboost', 'XGBoost'),
        ('random_forest', 'Random Forest'),
        ('lightgbm', 'LightGBM'),
        ('ensemble', 'Ensemble')
    ], string='Model Type', required=True, tracking=True)
    model_file = fields.Binary('Model File', required=True, attachment=True, tracking=True)
    model_filename = fields.Char('Model Filename')
    scaler_file = fields.Binary('Scaler File', attachment=True, tracking=True)
    scaler_filename = fields.Char('Scaler Filename')
    features_file = fields.Binary('Features File', attachment=True, tracking=True)
    features_filename = fields.Char('Features Filename')
    active = fields.Boolean('Active', default=True, tracking=True)
    creation_date = fields.Date('Creation Date', default=fields.Date.today, tracking=True)
    last_trained = fields.Datetime('Last Trained', tracking=True)
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company, tracking=True)

    # Additional fields for demand prediction models
    supports_stockouts = fields.Boolean('Supports Stockout Analysis', default=True, tracking=True)
    supports_seasonality = fields.Boolean('Supports Seasonality', default=True, tracking=True)

    def action_retrain_model(self):
        self.ensure_one()
        return {
            'name': _('Retrain Model'),
            'type': 'ir.actions.act_window',
            'res_model': 'retrain.demand.model.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_model_id': self.id},
        }

    def train_model(self, training_data=None):
        """
        Train or retrain the model
        This is a placeholder method that would normally train your ML model
        """
        self.ensure_one()

        # Log the start of the operation
        start_time = time.time()
        log_vals = {
            'name': 'Train Model',
            'model_id': self.id,
        }

        try:
            # In a real implementation, this would train your ML model
            # For now, we'll just update the last_trained field
            self.write({
                'last_trained': fields.Datetime.now(),

            })

            # Log success
            execution_time = time.time() - start_time
            log_vals.update({
                'status': 'success',
                'message': f"Successfully trained model {self.name}",
                'execution_time': execution_time
            })
            self.env['demand.prediction.log'].create(log_vals)

            return True

        except Exception as e:
            # Log failure
            execution_time = time.time() - start_time
            log_vals.update({
                'status': 'failed',
                'message': f"Error training model: {str(e)}",
                'execution_time': execution_time
            })
            self.env['demand.prediction.log'].create(log_vals)

            return False


class DemandPredictionLog(models.Model):
    _name = 'demand.prediction.log'
    _description = 'Demand Prediction Log'
    _order = 'date desc, id desc'

    name = fields.Char('Operation', required=True)
    date = fields.Datetime('Date', required=True, default=fields.Datetime.now)
    user_id = fields.Many2one('res.users', string='User', required=True, default=lambda self: self.env.user)
    status = fields.Selection([
        ('success', 'Success'),
        ('failed', 'Failed')
    ], string='Status', required=True)
    message = fields.Text('Message')
    execution_time = fields.Float('Execution Time (s)')
    batch_id = fields.Many2one('demand.prediction.batch', string='Batch' , ondelete='cascade')
    model_id = fields.Many2one('demand.prediction.model', string='Model')
    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.company)

    @api.model
    def log_operation(self, operation, status, message, execution_time=0.0, batch_id=False, model_id=False):
        """Create a log entry for an operation"""
        vals = {
            'name': operation,
            'status': status,
            'message': message,
            'execution_time': execution_time,
            'batch_id': batch_id,
            'model_id': model_id,
        }
        return self.create(vals)
